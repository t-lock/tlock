<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>tlock.dev</title>
  </head>
  <body>
    <style>
      :root {
        /* Rose Pine Moon */
        /* --bg-dark: #232136; proper color, no transparency */
        --bg-dark: #232136de; /* slight transparency */
        --bg-light: #2a273f;
        --bright: #f0bd75;
        --light: #e0def4;
        --med: #9ccfd8;
        --dark: #c4a7e7;
        --darker: #ea9a97;
        --darkest: #3e8fb0;
        --comment: #6e6a86;
      }

      body {
        font-family: monospace;
        margin: 20px;
        background-color: var(--bg-light);
        color: var(--light);
        letter-spacing: 0.1em;
        line-height: 1.5;

        display: flex;
        flex-direction: column;
        justify-content: center;
        align-items: center;
      }

      canvas {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        z-index: -1;
      }

      .col {
        background-color: var(--bg-dark);
        padding: 10px 30px;
        border: 1px solid var(--darker);
        border-radius: 6px;
        box-shadow: 2px 2px 8px 0px var(--bg-dark);
        max-width: 720px;
      }

      em {
        color: var(--bright);
      }

      small {
        color: var(--comment);
      }

      h1 {
        background-color: var(--bg-light);
        border-radius: 6px;
        margin-bottom: 40px;
        padding-left: 12px;
      }

      .prompt {
        color: var(--med);
      }
      .carat {
        display: inline-block;
        transform: scaleX(0.5) scaleY(1.5);
        margin-left: 10px;
        position: relative;
        top: 2px;
      }
      .cursor {
        opacity: 0.6;
        transition: opacity 75ms linear;
      }
      .cursor.hide {
        opacity: 0;
      }

      hr {
        border-color: var(--comment);
        opacity: 0.5;
        margin: 40px 0;
      }

      .note {
        color: var(--darkest);
        font-size: 1.2em;
        display: inline-block;
        margin-bottom: 10px;
        margin-left: -20px;
      }

      li + .note {
        margin-top: 20px;
      }

      span,
      li {
        font-size: 1.2em;
        padding: 4px 0;
        list-style: square;
        color: var(--dark);
      }

      p {
        color: var(--dark);
        font-size: 1.2em;
        line-height: 1.8;
      }

      a {
        color: var(--darker);
        display: inline-block;
        padding: 2px 4px;
        border-radius: 4px;
      }
      a:hover {
        opacity: 0.7;
      }
      a:focus,
      a:focus-within,
      a:focus-visible {
        opacity: 0.7;
        outline: none;
        background-color: var(--bg-light);
      }

      @media (max-width: 580px) {
        body {
          margin: 0;
        }
        .col {
          border: 0;
        }
      }
    </style>

    <canvas></canvas>

    <div class="col">
      <h1>
        <span class="prompt">~<span class="carat">></span></span>
        tlock.dev<span class="cursor">â–ˆ</span>
      </h1>

      <span>
        Find me at: <a href="https://armyofbees.com">Army of Bees</a> |
        <a href="https://furanoavalanche.org">Furano Avalanche Center</a> |
        <a href="https://github.com/t-lock">Github</a>
      </span>

      <hr />

      <h2>Current <em>Passion Project</em>:</h2>

      <!-- prettier-ignore -->
      <!--<span>
        <strong>Sveltempl</strong>
        (<a href="https://github.com/t-lock/sveltempl">Github</a>)
        (<a href="https://sveltempl.tlock.dev">Demo</a>)
      </span>

      <br /><br />-->

      <p>
        <strong>Writing an interpreter in Zig</strong>
      </p>
      <p>
        I'm following along with Thorsten Ball's excellent book: <em>Writing an Interpreter in Go</em>, but implementing everything in Zig. Zig is a very cool language and an excellent introduction to manual memory management through its unique use of typed allocators. Ball never claimed his Monkey-language compiler was optimized for performance (quite the opposite), so Zig's memory management patterns have presented obvious opportunities to re-think things: "Is there a way to do this bit <em>without</em> heap allocations?. Fun.
      </p>
      <hr />

      <h2>Tech I <em>truly care about</em>:</h2>

      <ul>
        <li>Linux</li>
        <li>Svelte</li>
      </ul>

      <small style="font-size: 1.1em">
        There are others that <em>almost</em> make this list. But these two were
        <em>love</em> at first sight and have <em>never waned.</em>
      </small>

      <hr />

      <h2>Languages I am <em>keen on</em>:</h2>
      <ul>
        <li>Go</li>
        <li>Zig</li>
        <li>Rescript</li>
        <li>Gleam</li>
      </ul>

      <hr />

      <h2>Languages I am <em>using in production</em>:</h2>

      <ul>
        <strong class="note">@ front-end</strong>
        <li>Typescript</li>
        <li>Javascript</li>
        <li>CSS</li>
        <li>Sass</li>
        <li>PostCSS</li>
        <strong class="note">@ back-end</strong>
        <li>Typescript</li>
        <li>SQL/plpgsql</li>
        <li>Go</li>
        <li>Python</li>
        <li>Ruby</li>
        <li>PHP</li>
      </ul>

      <hr />

      <h2>
        Tech / Frameworks / Platforms <small>etc</small> I am
        <em>using in production</em>:
      </h2>

      <ul>
        <strong class="note">@ front-end</strong>
        <li>Svelte</li>
        <li>React</li>
        <li>MobX + vanilla JS</li>
        <strong class="note">@ back-end</strong>
        <li>SvelteKit</li>
        <li>Deno</li>
        <li>Bun</li>
        <strong class="note">@ cloud db / serverless</strong>
        <li>Supabase</li>
        <li>Firebase</li>
        <li>AWS <small>...too many to list</small></li>
        <li>Hasura</li>
        <strong class="note">@ ssg / headless</strong>
        <li>Hugo</li>
        <li>Netlify CMS</li>
        <li>Gatsby <small>... but never again</small></li>
        <strong class="note">@ monolith</strong>
        <li>Ruby on Rails</li>
        <li>Wordpress</li>
        <strong class="note">@ toolchain</strong>
        <li>Vite</li>
        <li>Webpack</li>
        <li>Rollup</li>
        <li>Parcel</li>
      </ul>
    </div>

    <script>
      const cursor = document.querySelector(".cursor");
      setInterval(() => {
        cursor.classList.toggle("hide");
      }, 1000);
    </script>

    <script>
      (function () {
        // setup
        let canvas = document.querySelector("canvas");
        let c = canvas.getContext("2d");
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;

        window.addEventListener("resize", () => {
          canvas.width = window.innerWidth;
          canvas.height = window.innerHeight;
        });

        // hexagon facts
        let hexHeight = 150;
        const hexWidth = (hexHeight * Math.sqrt(3)) / 2;
        const hexAngleDegrees = 30;
        const hexAngle = (hexAngleDegrees * Math.PI) / 180;
        const hexSideLength = hexHeight / 2;
        const hexRadius = Math.cos(hexAngle) * hexSideLength;

        // rose pine moon
        const bgDark = "#232136de"; /* slight transparency */
        const bgLight = "#2a273f";
        const bright = "#f0bd75";
        const light = "#e0def4";
        const med = "#9ccfd8";
        const dark = "#c4a7e7";
        const darker = "#ea9a97";
        const darkest = "#3e8fb0";
        const comment = "#6e6a86";

        // hexagon
        function Hexagon(height, x, y) {
          this.radius = 0;
          this.x = x;
          this.y = y;

          this.draw = function () {
            c.beginPath();
            c.moveTo(
              this.x + this.radius * Math.sin(0),
              this.y + this.radius * Math.cos(0)
            );
            for (var side = 0; side < 7; side++) {
              c.lineTo(
                x + this.radius * Math.sin((side * 2 * Math.PI) / 6),
                y + this.radius * Math.cos((side * 2 * Math.PI) / 6)
              );
            }
            c.strokeStyle = med;
            // c.fillStyle = "";
            c.stroke();
            // c.fill();
          };

          this.update = function () {
            // get the distance from delayed pointer
            const a = pointer.delayed.x - this.x;
            const b = pointer.delayed.y - this.y;
            const dist = Math.sqrt(a * a + b * b);

            // interactivity
            const spotlightRadius = Math.max(window.innerWidth, 300);
            const maxHexRadius = hexHeight;
            if (dist <= spotlightRadius) {
              c.globalAlpha = 1 - dist / spotlightRadius;
              this.radius =
                maxHexRadius - (dist / spotlightRadius) * maxHexRadius;
            } else {
              c.globalAlpha = 0;
              this.radius = 0;
            }

            this.draw();
          };
        }

        // grid of hexagons
        let hexArr = [];
        function drawGrid() {
          const gridCellWidth = hexWidth;
          const gridCellHeight = hexHeight - (hexHeight - hexSideLength) / 2;
          const cols = Math.floor(canvas.width / gridCellWidth) + 2;
          const rows = Math.floor(canvas.height / gridCellHeight + 2);

          for (let i = 0; i < cols; i++) {
            for (let j = 0; j < rows; j++) {
              const x = i * hexWidth + (j % 2) * hexRadius;
              const y = j * (hexSideLength + hexSideLength / 2);
              hexArr.push(new Hexagon(hexHeight, x, y));
            }
          }
        }
        drawGrid();

        // mouse pointer tracking
        var mouse = {
          x: canvas.width / 2,
          y: canvas.height / 2,
        };

        window.addEventListener("mousemove", function (e) {
          mouse.x = e.x;
          mouse.y = e.y;
        });

        function Pointer(x, y) {
          this.x = x;
          this.y = y;
          this.delayed = { x: x, y: y };

          this.update = function () {
            this.delayed.x += (mouse.x - this.delayed.x) * 0.05;
            this.delayed.y += (mouse.y - this.delayed.y) * 0.05;
          };
        }
        const pointer = new Pointer(mouse.x, mouse.y);

        // canvas animation frames
        function animate() {
          requestAnimationFrame(animate);
          c.clearRect(0, 0, innerWidth, innerHeight);

          for (var i = 0; i < hexArr.length; i++) {
            hexArr[i].update();
          }

          pointer.update();
        }
        animate();
      })();
    </script>
  </body>
</html>
